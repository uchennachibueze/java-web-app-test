// import hudson.model.*
// import hudson.plugins.git.*

pipeline {
  agent any
  stages {
    stage('Checkout') {
      steps {
        script {
          git url: 'https://github.com/uchennachibueze/salesforcetest', branch: 'main'
        }
      }
    }
ggg
    stage('Test') {
      steps {
        script {

          def lastFailedSequence = getLastFailedSequence(JOB_NAME)
                    
          // Store the returned value in a list
          def failedBuildNumbers = []
          def commitHashes = []
                    
          // Output the last sequence of failed builds and store their numbers
          println "Last sequence of failed builds for job ${JOB_NAME}:"
          lastFailedSequence.each { build ->
            println "Build #${build.number} - ${build.getTimestampString()}"
            failedBuildNumbers << build.number

            def changeSet = build.getChangeSet()
              changeSet.each { change ->
                  commitHashes << change.commitId
              }
            }

          // Use the list of failed build numbers
          println "List of failed build numbers: ${failedBuildNumbers}"
          println "List of commit hashes: ${commitHashes}"
          def ln = System.getProperty('line.separator')
          println "---------------Groovy Changelog script Started---------------$ln"
          def previousBuild = currentBuild.previousBuild
          // def previousBuild = currentBuild.rawBuild.getPreviousBuild()
          // def previousBuildNumber = previousBuild.getNumber()
          // println "PRev: ${previousBuildNumber}"
          // def specificBuild = Jenkins.instance.getItemByFullName(env.JOB_NAME).getBuildByNumber(previousBuildNumber)
          println "Previous Build: ${previousBuild}"
          // println "Previous Build Result: ${previousBuild.result}"
          // println "Previous Build Number: ${previousBuild.number}"
          println "GIT_COMMIT: ${env.GIT_COMMIT}"

         
          if (previousBuild != null) {
              def failedBuilds = []
              //def changeSets = previousBuild.getChangeSets()
              def result = previousBuild.getResult()
              if (result == 'FAILURE') {
                failedBuilds << previousBuild.getNumber()
                //println "Failed Build List: $failedBuilds"
              } 
//else if (result == 'SUCCESS') {
  //                failedBuilds = []
    //              println "Failed Build Reset: $failedBuilds"
      //        }

              //for (changeSet in changeSets) {
                //  for (entry in changeSet.getItems()) {
                  //    println "Commit: ${entry.commitId}"
                    //  println "Author: ${entry.author}"
                      //println "Message: ${entry.msg}"
                    //}
                //}
            } else {
                println "Build number ${buildNumber} not found."
            }
        }
      }
    }
  }
}
// def ln = System.getProperty('line.separator')
// println "---------------Groovy Changelog script Started---------------$ln"

// def lastSuccessfulBuild = build.previousNotFailedBuild
// def failed = build.result != hudson.model.Result.SUCCESS
// def previousBuild = currentBuild.previousBuild

// println "Last Successful Build: ${lastSuccessfulBuild}"
// println "Current Build Result, is failed?: ${failed}"


// def currResult = build.result
// def prevResult = build.previousBuild?.result ?: null
// def consecutiveSuccess = currResult == hudson.model.Result.SUCCESS && prevResult == hudson.model.Result.SUCCESS

// def builds = []
// def changes = []
// def count = 0

// if (consecutiveSuccess) {
//     println "Last Build was successful, getting latest changes$ln"
//     builds << build
//     def changeItems = build.changeSet.items
//     println "Change Items: ${changeItems}$ln"
//     count += changeItems.length
//     changes += changeItems as List
// } else {
//     println "Last Build was not successful, getting changes from all failed builds as well$ln"
//     while (lastSuccessfulBuild) {
//         builds << lastSuccessfulBuild
//         def changeSet = lastSuccessfulBuild.changeSet
//         if (!changeSet.emptySet) {
//             def changeItems = lastSuccessfulBuild.changeSet.items
//             count += changeItems.length
//             changes += changeItems as List
//         }
//         lastSuccessfulBuild = lastSuccessfulBuild.nextBuild
//     }
// }

// def file = new File(build.getEnvVars()["WORKSPACE"] + '\\changelog')
// file.delete()
// file = new File(build.getEnvVars()["WORKSPACE"] + '\\changelog')

// if (count == 0) {
//     file << "No changes.$ln"
// }

// changes.each { item ->
//     println "item: $item$ln"
//     println "author: $item.authorName$ln"
//     println "msg: $item.msg$ln"
//     println "id: $item.id$ln"
//     println "revision: $item.revision$ln"
//     println "comment: $item.comment$ln"
//     println "commentAnnotated: $item.commentAnnotated$ln"
//     println "affectedFiles: $item.affectedFiles$ln"
//     println "affectedPaths: $item.affectedPaths$ln"
//     println "commitId: $item.commitId$ln"
//     println "timestamp: $item.timestamp$ln"
// }
@NonCPS
def getLastFailedSequence(jobName) {
    // Get the Jenkins instance
    def jenkins = Jenkins.instance

    // Get the job
    def job = jenkins.getItemByFullName(jobName)

    // Initialize a list to hold the current sequence of failed builds
    def currentFailedBuilds = []
    // Initialize a list to hold the last sequence of failed builds
    def lastFailedSequence = []

    if (job) {
        // Iterate through all builds of the job in reverse order (most recent first)
        job.getBuilds().reverse().each { build ->
            if (build.result == Result.FAILURE) {
                // Add the failed build to the current sequence
                currentFailedBuilds << build
            } else if (build.result == Result.SUCCESS) {
                // If a successful build is found, update the lastFailedSequence
                if (!currentFailedBuilds.isEmpty()) {
                    lastFailedSequence = currentFailedBuilds
                    // Reset the currentFailedBuilds list
                    currentFailedBuilds = []
                }
            }
        }

        // If there are failed builds and no subsequent successful build, update the lastFailedSequence
        if (!currentFailedBuilds.isEmpty()) {
            lastFailedSequence = currentFailedBuilds
        }
    } else {
        echo "Job '${jobName}' not found."
    }

    return lastFailedSequence
}
