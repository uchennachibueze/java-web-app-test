// import hudson.model.*
// import hudson.plugins.git.*

pipeline {
  agent any
  stages {
    stage('Checkout') {
      steps {
        script {
          git url: 'https://github.com/uchennachibueze/salesforcetest', branch: 'main'
        }
      }
    }
hhhshs
    stage('Test') {
      steps {
        script {
          def failedBuildsCheck = getFailedBuilds(JOB_NAME)
          // Output the failed builds
          println "Failed builds for job ${JOB_NAME}:"
          failedBuildsCheck.each { build ->
            println "Build #${build.number}"
          }
          def ln = System.getProperty('line.separator')
          println "---------------Groovy Changelog script Started---------------$ln"
          def previousBuild = currentBuild.previousBuild
          // def previousBuild = currentBuild.rawBuild.getPreviousBuild()
          // def previousBuildNumber = previousBuild.getNumber()
          // println "PRev: ${previousBuildNumber}"
          // def specificBuild = Jenkins.instance.getItemByFullName(env.JOB_NAME).getBuildByNumber(previousBuildNumber)
          println "Previous Build: ${previousBuild}"
          // println "Previous Build Result: ${previousBuild.result}"
          // println "Previous Build Number: ${previousBuild.number}"
          println "GIT_COMMIT: ${env.GIT_COMMIT}"

         
          if (previousBuild != null) {
              def failedBuilds = []
              def changeSets = previousBuild.getChangeSets()
              def result = previousBuild.getResult()
              if (result == 'FAILURE') {
                failedBuilds << previousBuild.getNumber()
                println "Failed Build List: $failedBuilds"
              } 
//else if (result == 'SUCCESS') {
  //                failedBuilds = []
    //              println "Failed Build Reset: $failedBuilds"
      //        }

              for (changeSet in changeSets) {
                  for (entry in changeSet.getItems()) {
                      println "Commit: ${entry.commitId}"
                      println "Author: ${entry.author}"
                      println "Message: ${entry.msg}"
                    }
                }
            } else {
                println "Build number ${buildNumber} not found."
            }
        }
      }
    }
  }
}
// def ln = System.getProperty('line.separator')
// println "---------------Groovy Changelog script Started---------------$ln"

// def lastSuccessfulBuild = build.previousNotFailedBuild
// def failed = build.result != hudson.model.Result.SUCCESS
// def previousBuild = currentBuild.previousBuild

// println "Last Successful Build: ${lastSuccessfulBuild}"
// println "Current Build Result, is failed?: ${failed}"


// def currResult = build.result
// def prevResult = build.previousBuild?.result ?: null
// def consecutiveSuccess = currResult == hudson.model.Result.SUCCESS && prevResult == hudson.model.Result.SUCCESS

// def builds = []
// def changes = []
// def count = 0

// if (consecutiveSuccess) {
//     println "Last Build was successful, getting latest changes$ln"
//     builds << build
//     def changeItems = build.changeSet.items
//     println "Change Items: ${changeItems}$ln"
//     count += changeItems.length
//     changes += changeItems as List
// } else {
//     println "Last Build was not successful, getting changes from all failed builds as well$ln"
//     while (lastSuccessfulBuild) {
//         builds << lastSuccessfulBuild
//         def changeSet = lastSuccessfulBuild.changeSet
//         if (!changeSet.emptySet) {
//             def changeItems = lastSuccessfulBuild.changeSet.items
//             count += changeItems.length
//             changes += changeItems as List
//         }
//         lastSuccessfulBuild = lastSuccessfulBuild.nextBuild
//     }
// }

// def file = new File(build.getEnvVars()["WORKSPACE"] + '\\changelog')
// file.delete()
// file = new File(build.getEnvVars()["WORKSPACE"] + '\\changelog')

// if (count == 0) {
//     file << "No changes.$ln"
// }

// changes.each { item ->
//     println "item: $item$ln"
//     println "author: $item.authorName$ln"
//     println "msg: $item.msg$ln"
//     println "id: $item.id$ln"
//     println "revision: $item.revision$ln"
//     println "comment: $item.comment$ln"
//     println "commentAnnotated: $item.commentAnnotated$ln"
//     println "affectedFiles: $item.affectedFiles$ln"
//     println "affectedPaths: $item.affectedPaths$ln"
//     println "commitId: $item.commitId$ln"
//     println "timestamp: $item.timestamp$ln"
// }
@NonCPS
def getFailedBuilds(jobName) {
    // Get the Jenkins instance
    def jenkins = Jenkins.instance

    // Get the job
    def job = jenkins.getItemByFullName(jobName)

    // Initialize a list to hold failed builds
    def failedBuilds = []
    // Variable to track if the last build was successful
    boolean lastBuildSuccessful = false

    if (job) {
        // Iterate through all builds of the job in reverse order (most recent first)
        job.getBuilds().reverse().each { build ->
            // Check if the build result is FAILURE
            if (build.result == Result.FAILURE) {
                if (!lastBuildSuccessful) {
                    // Add the failed build to the list
                    failedBuilds << build
                }
            } else if (build.result == Result.SUCCESS) {
                // Reset the failed builds list and set the flag
                failedBuilds = []
                lastBuildSuccessful = true
            }
        }
    } else {
        echo "Job '${jobName}' not found."
    }

    return failedBuilds
}
